#!/usr/bin/python3
# File has 3 parts (Very very losely MVC not really):
# 1. Config Logic: Argument handling, .config directory setup, initialization
# 2. Program Logic: Phrase Selection, View control, Program Loop
# 3. View Logic: TUI interface, display logic, display functions
# Everything is going to be contained in one file because the goal is for setup to be as easy as possible.
#    This is not meant to be super complex its just a simple application.
import sys
import os
import json
import signal

conf_path = os.environ.get("HOME") + ".config/flashtorom/"

def main():
    if not os.path.exists(conf_path + "config"):
        os.makedirs(conf_path)

        with open(conf_path + "config", "w") as config_file:
            default_config = {
                    "read" : True,
                    "write" : True,
                    "letters" : True,
                    "words" : True,
                    "phrases" : True
                    }
            config_file.writelines(json.dumps(default_config, indent=2))

    config = Configuration()
    wordlist = config.getWordList()
    config = config.getConfiguration()

# Configuration Logic
class Configuration:
    config = {}
    def __init__(self):
        # loop variables
        counter = 1
        argStore = None
        # Used to create a config by looking up a dictionary and executing lambda's instead of if statments.
        # A re-invention of the wheel but i like it
        args  = {
                '-h' : lambda config:printHelp(),
                '-r' : lambda config:config.update({'read':True}),
                '-w' : lambda config:config.update({'write':True}),
                '-l' : lambda config:config.update({'letters':True}),
                '-W' : lambda config:config.update({'words':True}),
                '-p' : lambda config:config.update({'phrases':True}),
                '-a' : lambda config:config.update({'letters': True, 'words':True, 'phrases':True}),
                '--setdefault' : lambda config:self._setConfigurationDefaults(config),
                '-u' : lambda config, name=None:
                  config.update({'use':name}) if name is not None else False,
                '--setdefaultlist' : lambda config, name=None:
                  self._setDefaultList(name) if name is not None else False,
                }

        # default parameter logic
        self.config.update(self._getDefaultList())
        if len(sys.argv) == 3 and sys.argv[1] == "-u":
            self.config.update(next(self.getConfigurationDefaults))
        if len(sys.argv) == 1:
            self.config.update(next(self.getConfigurationDefaults))
            return

        # loop through args
        while counter < len(sys.argv):
            arg = sys.argv[counter]
            try:
                # store result of lambda in result
                result = args.get(arg)(self.config) if argStore is None else args.get(argStore)(self.config,arg)
                # clear argstore once we are done using the argument
                argStore = None
                if result is not None:
                    # store the current argument if we need it for the next execution
                    argStore = arg
            except Exception:
                print("Invalid argument" + arg)
                printHelp()
            counter = counter + 1

    def getConfiguration(self)->dict:
        return self.config

    # makes a word list
    def getWordList(self)->dict[str:list:tuple]:
        words = {"letters" : [], "words" : [], "phrases" : []}
        current_type = ""
        list_name = self.config.get("use",None)
        # Some validation checks for file existance
        if list_name is not None:
            if not os.path.exists(conf_path + list_name):
                print("The wordlist you provided was not found under the config directory")
                exit()

            with open(conf_path + list_name, "r") as word_list:
                lines = word_list.readlines()

                # Validation for first line
                if len(lines) < 1 or lines[0].find("$$") < 0:
                    print("Wordlist is not well formed.")
                    print("You require each section to start with $$.")
                    print("The first line must be a section header. See ReadMe")
                    exit()

                for line in lines:
                    potential_pair = line.split("=")
                    # body of a section case
                    if len(potential_pair) == 2:
                        native, learning = potential_pair
                        native.strip()
                        learning.strip()
                        words[current_type].append((native,learning))
                    # header of a section case
                    elif len(potential_pair) == 1 and potential_pair[0].find("$$ ") == 0:
                        # Getting the word (letters, words, phrases) from the heading, standardizing case
                        current_type = potential_pair[0].split("$$")[0].strip().lower()
                        # Validating section name
                        try:
                            words.get(current_type)
                        except Exception:
                            print("Invalid section name: " + current_type)
                            exit()
                    # bad body of a section case
                    elif len(potential_pair) > 2:
                        print("You have multiple = signs in your wordlist on one line, that is not allowed")
                        print("This is the problem child: " + line)
                        exit()
                    # edge case
                    else:
                        print("hmm, this is not supposed to happen. Look at this line")
                        print(line)
                        exit()
        else:
            print("You need to set your default language/word list, see ReadMe.")
            exit()
        return words

    # this is not the best solution, but its a interesting solution
    def _getConfigurationDefaults(self) -> dict:
        content = ""
        with open(conf_path + "config", 'r') as config_file:
            content = config_file.read()
        result = json.loads(content)
        while True:
            yield result

    def _setConfigurationDefaults(self, config:dict):
        # ignore -u
        config.update(self._getDefaultList())
        #Save to conf
        with open(conf_path + "config", "r") as config_file:
            config_file.writelines(json.dumps(config, indent=2))

    def _getDefaultList(self)->dict:
        default_config = next(self._getConfigurationDefaults)
        return {"use" : default_config.get("use",None)}

    def _setDefaultList(self,name):
        # get current conf
        config = next(self._getConfigurationDefaults)
        config.update({"use":name})
        with open(conf_path + "config", "w") as config_file:
            config_file.writelines(json.dumps(config, indent=2))
        exit()

# Program Logic


# UI Display Logic
def printHelp():
    print("help")
    exit()

def debugOut(out):
    print(out)

# Contains all the UI display logic availible methods are:
# 1. set_question(title,question,answer) which makes a dialogue with answer hidden.
# 2. toggle_answer_visibility() changes visibility of answer.
class UI:
    buffer = []
    answer_visible = False


    # Sets Question information, resets answer visibilty to false, display question
    def set_question(self,title,question,answer):
        self.title = title
        self.question = question
        self.answer = answer
        self.answer_visible = False
        self._redraw()

    # Toggles visibilty of answer, redraws
    def toggle_answer_visibility(self):
        self.answer_visible = not self.answer_visible
        self._redraw()

    def __init__(self):
        self.columns, self.rows = os.get_terminal_size()
        self.title = ""
        self.question = ""
        self.answer = ""
        # updates terminal dimentions on resize
        signal.signal(signal.SIGWINCH, self._resize_signal_event)

    # resize event
    def _resize_signal_event(self, signum, frame):
        self.columns, self.rows = os.get_terminal_size()
        self._redraw()

    # goes through buffer and draws out everything.
    # Newlines must be placed in strings
    def _redraw(self):
        self.buffer = []
        self._set_buffer()
        #clear
        print("\033c", end="")
        #read buffer
        for instruction in self.buffer:
            print(instruction, end="")

    # For now this just calls cli function but in future might
    # Be able to switch between CLI and TUI
    def _set_buffer(self):
        self._write_cli_to_buffer(self.title, self.question, self.answer)

    # CLI simple interactive line by line
    def _write_cli_to_buffer(self, title, question, answer):
        self.buffer.append(title)
        self.buffer.append(question)
        self.buffer.append(answer) if self.answer_visible else None

    # Uses a more visually interesting UI
    def _write_tui_to_buffer(self, xy:tuple, title, question, answer, answer_visible):
        # TODO: Unicode character width is a issue that I still thinking of how to deal with. Leaving this for future implimentation
        return

    # Determines width of text so that it can be centered properly
    def _text_width(self, text:str)->tuple:
        # TODO: Unicode character width is a issue that I still thinking of how to deal with. Leaving this for future implimentation
        return

    # Moves cursor in terminal. Used for constructing TUI
    def _move_cursor(self, x, y):
        self.buffer.append(f'\033[{y};{x}H')

if __name__ == "__main__":
    main()
